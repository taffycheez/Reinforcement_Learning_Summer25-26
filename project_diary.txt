WEDNESDAY 12/11/25
Began by thinking about how to represent a state of a game of tic-tac-toe efficiently in a computer. 
The initial suggestion was a string of characters e.g. "xo__oxxox". My next thought was a list of numbers
e.g. [2,1,0,0,1,2,2,1,2]. Then I thought, why not just one number? I was stumped on how to implement this, 
but a quick Google search led me to the concept of a 'bitboard', which apparently is the way states of a 
game of chess are implemented. In chess, the 8x8 board is represented as a 64-bit binary number, with one
number for each type of piece (pawn, knight, etc); a '0' means the piece is absent from that square, whereas
a '1' means the piece occupies that square. 

I spent about 2 hours implementing this in Python for a tic-tac-toe game. As I had never worked with binary
numbers before, there was a learning curve, but this (https://www.geeksforgeeks.org/python/python-bitwise-operators/) 
GeeksForGeeks page was helpful. I used two 9-bit binary numbers to implement a board. This felt inefficient, as it meant
a 16-bit block would have to be allocated for each number, with 7 bits free. However, apparently Python stores 
integers in blocks of size 28 or more by default, which made me feel a bit better. If implementing this code in C
or similar, it might be a good idea to use 32-bit blocks (4 bytes per number, less space wasted) by storing each game
state as a single binary number (size 18 bits).

Since the number of naughts had to be equal, or one less, than the number of crosses, I counted each using the .bit_count()
method and checked this. I also needed a way to check that each square was only occupied by one (or none) of naughts or crosses,
and found my solution in the '&' operator (discovered in the above GeeksForGeeks page). This returns '1' only if both bits in 
a position are '1', so I needed naughts & crosses to always be '000000000' - i.e. the number 0. Finally, I needed only one of 
naughts and crosses to have won. With some help from Grok, I checked this by having a list of 'winning positions' (top row full,
leftermost column full, upper left to lower right diagonal full, etc.). Firstly I decided that neither naughts nor crosses could
win (so naughts & w != w, crosses & w != w for all w in winning_positions) but then I realised I did actually need to keep track
of valid winning positions, so came up with the following final code to check the state of a game:

def valid_state(naughts, crosses):
    """Checks whether the given tic-tac-toe bitboard represents a valid state of the game."""
    # Each square must be occupied by only one piece
    # So naughts AND crosses must return 0
    n_0 = naughts.bit_count()
    n_x = crosses.bit_count()
    if naughts & crosses != 0:
        return False
    # Number of crosses = number of naughts (or number of naughts + 1)
    # So if no_naughts > no_crosses or no_crosses > no_naughts + 1, invalid state
    if (n_0 > n_x) or (n_x > n_0 + 1):
        return False
    # Valid non-final position cannot have a row, column, or diagonal filled by one symbol
    # So naughts/crosses AND any winning state cannot return the winning state
    # I.e. naughts/crosses cannot have a winning position filled
    for winning_position in winning_positions:
        if ((naughts & winning_position == winning_position) and (n_0 != n_x)) or ((crosses & winning_position == winning_position) and (n_x != n_0 + 1)):
            return False
    return True

Then all that remained was to loop through all possible combinations of numbers corresponding to tic-tac-toe bitboards and, if valid,
append them to a list of valid states. 

def return_states():
    """Returns all possible valid states of tic-tac-toe."""
    possible_states = []
    # The greatest number that a naughts position can correspond to is 480 (111100000)
    # For a crosses position this is 496 (111110000)
    for naughts in range(0, 481):
        for crosses in range(0,497):
            if valid_state(naughts, crosses):
                possible_states.append((naughts, crosses))
    return possible_states

This loop runs 481 x 497 = 239,057 times, and produced 5478 valid states (or 4536 valid non-winning states) in just tenths of a second.

Searching to check if I had the right number of states, I found a paper titled 'A Combinatorial Analysis of Tic-Tac-Toe and The
Theoretical Advantage of Playing First'; not wanting to 'spoil' too much for myself, I only read the first section, which told me that
there are indeed 5478 possible game states. This is because:
- there are 9 positions, and 3 possible values (o, x, empty) for each position, so 3^9 = 19,683 ways to put (or not put) x and o on a board
- but following the rules of the game, firstly, n洧 + 洧녵洧논 + 洧녵洧녶 = 9; n洧논 = 洧녵洧녶 洧녶洧 洧녵洧논 = 洧녵洧녶 + 1;. Then considering that naughts, crosses, and empty
spots are indistinguishable, the number of combinations at each value of ne, nx, no is 9!/ne!nx!no!. That is:
洧녞(9; 0, 0, 9) =
9!
0!0!9!
= 1
After turn 1 (洧녵洧논 = 1, 洧녵洧녶 = 0, 洧녵洧 = 8):
洧녞(9; 1, 0, 8) =
9!
1!0!8!
= 9
After turn 2 (洧녵洧논 = 1, 洧녵洧녶 = 1, 洧녵洧 = 7):
洧녞(9; 1, 1, 7) =
9!
1!1!7!
= 72 
After turn 3 (洧녵洧논 = 2, 洧녵洧녶 = 1, 洧녵洧 = 6):
洧녞(9; 2, 1, 6) =
9!
2!1!6!
= 252
After turn 4 (洧녵洧논 = 2, 洧녵洧녶 = 2, 洧녵洧 = 5):
洧녞(9; 2, 2, 5) =
9!
2!2!5!
= 756
After turn 5 (洧녵洧논 = 3, 洧녵洧녶 = 2, 洧녵洧 = 4):
洧녞(9; 3, 2, 4) =
9!
3!2!4!
= 1260
After turn 6 (洧녵洧논 = 3, 洧녵洧녶 = 3, 洧녵洧 = 3):
洧녞(9; 3, 3, 3) =
9!
3!3!3!
= 1680 
After turn 7 (洧녵洧논 = 4, 洧녵洧녶 = 3, 洧녵洧 = 2):
洧녞(9; 4, 3, 2) =
9!
4!3!2!
= 1260
After turn 8 (洧녵洧논 = 4, 洧녵洧녶 = 4, 洧녵洧 = 1):
洧녞(9; 4, 4, 1) =
9!
4!4!1!
= 630
After turn 9 (洧녵洧논 = 5, 洧녵洧녶 = 4, 洧녵洧 = 0):
洧녞(9; 5, 4, 0) =
9!
5!4!0!
= 126 
So there are 1 +9 + 72 +252 + 756 + 1260 + 1680 + 1260 +630 + 126 = 6046 reachable game states so far. However, we must consider
that only one player can win at a time. Now, after crosses' turn, there is one more cross than naught. After naughts' turn, there
are as many naughts as crosses. So, after naughts have won (meaning the game is ended, and cross doesn't get their next turn) there
must be as many naughts as crosses; and after crosses have won, there must be one more cross than naught. This eliminates the following
states:
8 칑 洧녞(6; 0, 3, 3) = 8 칑
6!
0!3!3!
= 8 칑 20 = 160 (21)
8 칑 洧녞(6; 1, 4, 1) = 8 칑
6!
1!4!1!
= 8 칑 30 = 240 (22)
8 칑 洧녞(6; 4, 0, 2) = 8 칑
6!
4!0!2!
= 8 칑 15 = 120 (23)
8 칑 洧녞(6; 5, 1, 0) = 8 칑
6!
5!1!0!
= 8 칑 6 = 48 (24)
160 + 240 +120 + 48 = 568
6046 - 568 = 5478, our final answer. 
https://informatika.stei.itb.ac.id/~rinaldi.munir/Matdis/2021-2022/Makalah2021/Makalah-Matdis-2021%20(148).pdf

THURSDAY 13/11/25
Started thinking about generating the q-table today, and realised I would need to generate winning and gameplay states separately. Changed my code to do this,
returning 0 if invalid state, 1 if gameplay, 2 if win. 

Also spent some time making code to convert a bitboard representation of a tic-tac-toe game to a visual one. 

Finally created code to fill up q-table for states one move away from terminal. For each possible move, and each possible terminal state, check if
that move leads to that terminal state. 

for naughts, crosses in possible_states:
    n_0 = naughts.bit_count()
    n_x = crosses.bit_count()
    if n_0 == n_x: # Crosses' turn
        for n in range(9):
            for t in terminal_states:
                if (naughts, crosses + 2**n) == t[0]: # Adding 2^n changes the nth digit (starting at 0, going from the right) to a 1
                    q_table.append([(naughts, crosses), n, t[1]])
    else: # Naughts' turn
        for n in range(9):
            for t in terminal_states:
                if (naughts, crosses + 2**n) == t[0]:
                    q_table.append([(naughts, crosses), n, t[1]])

FRIDAY 14/11/25

Changed 'list_possible_states' code to generate a dictionary of states for each depth/number of moves passed. Using this created code to generate the q-table. 

For the q-table code first found indexes of available moves (using a binary string) and then for each of these indexes added 2^n to the player whose turn it was
and checked if this corresponded to a terminal state, or a state that had already been checked. did this for every depth, going down. 

q_table = {}

depth = 8 # initialise to states one move away from filling the board
while depth >= 0:
    higher_states = q_table.copy()
    print(higher_states)
    for naughts, crosses in possible_states[depth]:
        # naughts XOR crosses has 0 wherever there are two 0s in a position (free position) and 1 wherever a position is full
        free_positions = format(naughts ^ crosses, '09b')
        # so available moves are wherever a digit of the above result is 0
        available_moves = [8-i for i, bit in enumerate(free_positions) if bit == '0']
        if depth % 2 == 0: # crosses' turn
            for n in available_moves:
                for t in terminal_states:
                    if (naughts, crosses + 2**n) == t[0]:
                        q_table.setdefault((naughts, crosses), []).append((n, t[1]))
                # break somehow as a move can only lead to one state?
                for state, value in higher_states.items():
                    if (naughts, crosses + 2**n) == state:
                        q_table.setdefault((naughts, crosses), []).append((n, value[0][1]))

        else: # naughts' turn
            for n in available_moves:
                for t in terminal_states:
                    if (naughts + 2**n, crosses) == t[0]:
                        q_table.setdefault((naughts, crosses), []).append((n, t[1]))
                # break somehow as a move can only lead to one state?
                for state, value in higher_states.items():
                    if (naughts + 2**n, crosses) == state:
                        q_table.setdefault((naughts, crosses), []).append((n, value[0][1]))
    depth -= 1

Then broke loops when a state-move combo was found using a found boolean and loop breaks. 

SATURDAY 15/11/25
Created this diary. 

SUNDAY 16/11/25
Finished filling in diary. 

Updated q-table code to only check state one higher. To implement this changed terminal_states to a dictionary of depth-(state, q). 

I feel like I am missing something. I don't think I'm factoring in the fact that I am playing against an optimal opponent. And I think my program is generating
too many moves. Maybe I did the code for the random opponent by mistake. I am just matching with the first thing that comes up instead of considering the best
move. 

MONDAY 17/11/25

Need to have q-table include terminal states as well. 

THURSDAY 27/11/25

Created txt file of list of possible states and summary of their types. Read through list_possible_states function and decided to create a 
state-value dictionary as suggested by Grok to increase efficiency when creating the q-table. Next stage is to alter my q-table generation code. 

Thinking about how many possible moves there should be:
There are 5478 states. 4520 of them are non-terminal. 
As established above:

0 moves - 1 state
1 move - 9 states
2 moves - 72
3 moves - 252
4 moves - 756
5 moves - 1260
6 moves - 1680-568=1112
7 moves - 1260
8 moves - 630